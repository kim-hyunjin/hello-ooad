# chapter 5 (part 1)
## 좋은 디자인 = 유연한 소프트웨어
### 인터페이스
- 구현보다는 <u>인터페이스</u>에 의존하도록 코딩하는 것이 소프트웨어를 <u>확장이 용이</u>하게 한다.
- 인터페이스에 의존하도록 코딩하면, 코드는 인터페이스의 서브 클래스 모두 - 심지어 아직 만들지 않은 클래스와도 - 와 잘 동작할 것이다.

### 캡슐화
- 캡슐화는 중복된 코드를 없애는 관점에서도 유용하지만, 복사-붙여넣기를 피하는 것 이상의 내용이 캡슐화의 개념에 있다.
- 캡슐화는 <b>클래스를 불필요한 변경으로부터 보호한다.</b>
- 변화의 가능성이 있다고 생각되는 프로그램의 기능이 있을 때, 그 기능을 자주 변하지 않을 부분과 분리해야 한다. 즉, 변경하는 것을 캡슐화하려는 노력이 항상 필요하다.

### 변경
- 소프트웨어에서 변하지 않는 진리는 소프트웨어는 변한다는 것이다. 설계가 잘 되어 있지 않은 소프트웨어는 처음 변경이 일어날 때 무너진다. 하지만 위대한 소프트웨어는 쉽게 변경될 수 있다.
- 소프트웨어를 변경에 잘 견디도록 만드는 가장 쉬운 방법은 <b>각 클래스가 변경의 이유를 하나만 갖도록 하는 것</b>이다. 다시 말해, 클래스 안의 변경 요인을 줄여 변경 가능성을 최소화하는 것이다.

### 응집도

```
Q: 응집도라는 게 프로그램이 쉽게 변경될 수 있는지 나타내는 건가요?
A: 그렇지 않아요. 응집도는 프로그램 안의 각 클래스, 객체, 그리고 패키지를 어떻게 구성했는지에 초점을 맞추고 있다. 각 클래스가 몇 가지 일만을 한다면, 그것은 아마 아주 응집도가 높은 소프트웨어일 것입니다.
하지만 하나의 클래스가 그다지 관련되지 않은 여러 졍류의 일을 한다면, 낮은 응집도의 프로그램인 것입니다.

Q: 높은 응집도의 소프트웨어는 느슨하게 결합되어 있는 것이 맞나요?
A: 맞습니다. 거의 모든 경우, 소프트웨어가 더 응집되어 있을수록, 클래스들간에 더 느슨한 결합을 갖게 됩니다.

Q: 그렇다면 소프트웨어가 더 변경하기 쉬울 거라는 거잖아요?
A: 대부분의 경우 맞습니다. 하지만 기본적으로 프로그램을 수정하면 이미 응집되어 있고 느슨하게 결합되어 있는 설계를 변경해야 할 때도 있습니다.
그래서 응집도가 언제나 소프트웨어가 변경하기 쉬운지에 대한 척도는 아닙니다. 하지만 소프트웨어의 동작 방식을 대폭 수정하는 경우아 아니라면, 응집도가 높은 소프트웨어가 대개 변경이 용이한건 맞습니다.

Q: 응집도가 높은 소프트웨어가 변경뿐만 아니라 재사용도 쉽지 않나요?
A: 맞아요. 높은 응집도와 느슨한 결합은, 소프트웨어 안의 객체들이 서로 의존하지 않게 하여, 확장하기 쉽고, 나눠서 재사용하기 쉬운 소프트웨어로 만듭니다.
이렇게 생각하세요: 프로그램에서 응집도가 높을수록, 각 객체가 할 일이 더 잘 정의된 것입니다. 그리고 객체(와 그 객체의 할 일)가 잘 정의될수록, 
그 객체를 끄집어 내어 다른 프로그램에서 같은 일을 하도록 하기 쉽습니다. 이러한 객체는 어디서 이용되더라도, 매우 기꺼이 자신이 맡은 특정한 일을 계속할 것입니다.
```

### 정리
1. 변하는 것을 캠슐화하여 프로그램을 더 유연하고 변경하기 쉽게 만든다.
2. 구현에 맞추어 코딩하는 것보다 인터페이스에 맞추어 코딩하면 소프트웨어의 확장이 더 쉬워진다.
3. 좋은 요구사항을 얻는 가장 좋은 방법은 시스템이 해야할 일을 이해하는 것이다.
4. 분석은 시스템이 실세계에서 잘 동작하도록 만드는 데 도움이 된다.
5. 위대한 소프트웨어는 변경과 확장이 쉽고 고객이 원하는 일을 한다.

## 디자인 원리
1. OCP(Open-Closed Principle) : 개방-폐쇄의 원리
- OCP는 기존 코드를 변경하지 않으면서 코드의 수정을 허용하는 것에 관한 원리이다.
- 클래스는 확장에는 열려있고, 수정에는 닫혀 있어야 한다.
- ex) private 변수와 setter, 클래스 상속
2. DRY(Don't Repeat Yourself) : 반복 금지의 원리
- 공통되는 부분을 추출하여 추상화하고 한 곳에 두어 중복 코드를 피하라.
- 하나의 요구사항은 한 곳에 두어야 한다.
3. SRP(Single Responsibility Principle) : 단일 책임의 원리
- 시스템의 모든 객체는 하나의 책임만을 가지며, 객체가 제공하는 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어 있어야 한다.
4. LSP(Liskov Substitution Principle) : 리스코프 치환 원리
- 자식 타입들은 부모 타입들이 사용되는 곳에 대체될 수 있어야 한다. 그렇지 않다면, 상속을 잘못 사용하고 있는 것이다.
- LSP를 위반하는 코드를 발견하면, 위임(Delegation), 구성(Composition), 또는 집합(Aggregation)을 사용하여
상속을 이용하지 않고 다른 클래스의 행동을 사용하는 것을 고려해보라.

#### 위임(Delegation)
- 다른 클래스의 행동이 필요한데 그 행동을 바꿀 필요가 없으면, 원하는 행동을 사용하기 위해 그 클래스에게 위임할 수 있다.

#### 구성(Composition)
- 인터페이스의 여러 구현을 통해 만들어진 비슷한 여러 행동으로부터 하나의 행동을 선택할 수 있게 한다.
- 구성을 사용하면 사용하는 객체가 자신이 사용하는 행동을 소유하고, 구성하는 객체가 사라지면 구성에 참여한 객체도 사라진다.

#### 집합(Aggregation)
- 다른 클래스의 생존에 영향을 미치지 않으면서 그 행동을 사용할 수 있게 한다.
- 집합에 참여한 클래스의 행동은 자신을 사용했던 집합 클래스가 사라진 후에도 계속 존재한다.